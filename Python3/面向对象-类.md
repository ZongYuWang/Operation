## 面向对象-类

##### 函数式编程和面向对象编程对比：

```ruby

函数式编程：
def search(self,back_domain):
    pass

def add(self,back_domain,record):
    pass
    
def delete(self,back_domain):
    pass
    
search("www.test.com")
add("www.test.com",xxxxx)

面向对象编程：
# 定义类（类就是封装了几个函数，在类中称为方法）
class haproxy:  # 定义类名

    def search(self,back_domain): # 定义方法
        pass

    def add(self,back_domain,record):
        pass
    
    def delete(self,back_domain):
        pass
    
obj = haproxy()  # 根据类创建对象（创建一个haproxy类的实例）
obj.search("www.test.com")   # 使用对象去执行类中方法
obj.add("www.test.com",xxxxxx)

【说明】通过上面的代码比对，反而面向对象的代码要复杂，所以面向对象不是所有情况都适用

```
![](https://github.com/ZongYuWang/image/blob/master/python-class1.png)

self详解：
```ruby

class haproxy:

    def search(self,back_domain):  # 定义类的成员(方法是类的成员)
        print(back_domain,self) # back_domain:'www.test.com'    self:<__main__.haproxy object at 0x021A48D0>

    def add(self,back_domain,record):
        pass

    def delete(self,back_domain):
        pass

obj_1 = haproxy()  # obj_1是类对象，obj_1：<__main__.haproxy object at 0x021A48D0>
print(obj_1)
obj_1.search("www.test.com")      # self:obj_1  back_domain:www.test.com
obj_2.search("www.wangzy.com")    # self:obj_2  back_domain:www.wangzy.com
```
`self其实就是所有类对象的一个变量，self参数不需要传递，只是形式参数，python会在内部自己传递 `   

*`输出:`*
```ruby
<__main__.haproxy object at 0x021A48D0>  # 输出的obj的地址
www.test.com <__main__.haproxy object at 0x021A48D0>  输出的back_domain值，和self地址值

【说明】其实就是把obj传递给了self
```

- ##### 封装：

使用场景：当同一类型的方法具有相同参数时，直接封装到对象即可`(封装方式二)`。
使用场景：把类当做模板，创建多个对象(对象内封装的数据可以不一样)`(方式二中的存档实验：创建多个用户，每个用户都可以存档和取档)`
```ruby
class haproxy:

    def search(self,back_domain):  # 需要传递一次back_domain
        pass

    def add(self,back_domain,record):  # 需要传递第二次back_domain
        pass

    def delete(self,back_domain):  # 需要传递第三次back_domain
        pass
      
search("www.test.com")  # 调用也需要输入三次
add("www.test.com")
delete("www.baidu.com")
```
所以这样也很麻烦，所以引入封装的概念：    

- 封装方式一：   

![](https://github.com/ZongYuWang/image/blob/master/python-class2.png)
```ruby
class haproxy:

    def search(self):
        print(self.back_domain)

    def add(self,record):
        pass

    def delete(self):
        pass

obj_1 = haproxy()
obj_1.back_domain = "www.test.com" # 在对象中封装数据
obj_1.search()

obj_2 = haproxy()
obj_2.back_domain = "www.wanzy.com"
obj_2.search()
```
*`输出`*
```ruby
www.test.com
www.wanzy.com
```
更为直观的解释：数据库操作  
```ruby
class mysqltest:

    def add(self,ip,port,username,password)  # 数据库的添加和删除都需要输入4个相同的信息
        pass
    
    def remove(self,ip,port,username,password)
        pass

obj1 = mysqltest()   # 使用这种方式将优化
obj1.host = "192.168.1.1"
obj1.port = "3306"
obj1.username = "root"
obj1.password = "test"

obj1.add()
obj1.remove()
```
- 封装方式二：   

```ruby
class Foo:

    def __init__(self):  # __init__有一个特殊的名字：构造方法
        print("print ->>>> %s" %self)

obj1 = Foo() # 类+()会自动执行类中的__init__方法，在__init__方法中执行具体封装的操作
obj2 = Foo()
```
*`输出`*
```ruby
print ->>>> <__main__.Foo object at 0x00214930>
print ->>>> <__main__.Foo object at 0x004CE8B0>
```
```ruby
class Domain:

    def __init__(self,bk):
        self.back_domain = bk   # 称为普通字段

    def search(self):
        print(self.back_domain)

    def add_record(self,record):
        print(self.back_domain)

    def del_record(self):
        print(self.back_domain)

obj1 = Domain("www.test.com")
obj1.search()
```
` __del__解释器销毁对象时候自动调用，特殊的名：析构方法 `

```ruby
class Person:

    def __init__(self,name,age):
        self.Name = name
        self.Age = age

    def chi(self):
        print("%s 吃" %self.Name)

user1 = Person("wang",20)
user2 = Person("baby",30)

user1.chi()
user2.chi()
```

结合pickle(存档)使用：  
```ruby
通过下面这个减肥实例，chi涨2斤，jianshen减1斤：

class Person:

    def __init__(self,name,age,weight):
        self.Name = name
        self.Age = age
        self.Weight = weight

    def chi(self):
        self.Weight = self.Weight + 2

    def jianshen(self):
        self.Weight = self.Weight - 1

user1 = Person("wang",20,200)
#user2 = Person("baby",30)

print(user1.Weight)
user1.chi()
print(user1.Weight)
user1.jianshen()
print(user1.Weight)


先存档(dump)：
class Person:

    def __init__(self,name,age,weight):
        self.Name = name
        self.Age = age
        self.Weight = weight

    def chi(self):
        self.Weight = self.Weight + 2

    def jianshen(self):
        self.Weight = self.Weight - 1


user1 = Person("wang",20,200)
user1.chi()
user1.jianshen()
pickle.dump(user1,open("cundang",'wb'))

取档(load):
import pickle
class Person:

    def __init__(self,name,age,weight):
        self.Name = name
        self.Age = age
        self.Weight = weight

    def chi(self):
        self.Weight = self.Weight + 2

    def jianshen(self):
        self.Weight = self.Weight - 1

ret = pickle.load(open("cundang","rb"),encoding="utf-8")  # 从这个文件中取出值

if ret:
    print(ret.Weight)

【说明】此实验中不能使用json，json只能处理python的基本数据类型
```

- ##### 继承：

```ruby
class Animals:   # 基类

    def chi(self):
        pass

    def he(self):
        print(self.name,"喝")

class Dog(Animals):  # 派生类，表示继承Animals类，继承谁就要写谁
    def __init__(self,name):
        self.name = name

    def jiao(self):
        print(self.name,"汪")

IT1 = Dog("wangzy")
IT1.chi()
IT1.he()
IT1.jiao()
```
- 派生类可以继承基类中所有的功能(同时也可以继承“爷爷”类)
- 派生类和基类同时存在时，优先找派生类(下面的例子说明)
```ruby
class Animals:

    def chi(self):     # 基类中有这个chi的类
        print(self.name,"吃的基类的")

    def he(self):
        print(self.name,"喝")


class Dog(Animals):
    def __init__(self,name):
        self.name = name

    def jiao(self):
        print(self.name,"汪")

    def chi(self):   # 派生类中也有这个chi的类,当然如果Dog的子类中也有这个类，则不会继承Dog子类的chi方法
        print(self.name,"吃的派生类的")

IT1 = Dog("wangzy")
IT1.chi()
IT1.he()
IT1.jiao()
```
*`输出`*
```ruby
wangzy 吃的派生类的
wangzy 喝
wangzy 汪
```
- Python类可以同时继承多个类(C#和Java不可以)
优先：自己、左边、右边
```ruby
class Animals:

    def chi(self):
        print(self.name,"吃的基类的")

    def he(self):
        print(self.name,"Animals类中喝")

    # def du(self):
    #     print(self.name,"Animals类中的赌")


class Uncle:
    def du(self):
        print(self.name,"Uncle家中赌")

    def piao(self):
        print(self.name,"Uncle家中piao")


class Dog(Animals,Uncle):  # 继承了两个类,左和右是对这个写的顺序而言
    def __init__(self,name):
        self.name = name

    def jiao(self):
        print(self.name,"自己的类中汪")

    def chi(self):
        print(self.name,"吃的派生类的")

IT1 = Dog("wangzy")
IT1.chi()
IT1.he()
IT1.jiao()
IT1.du()   # 自己中没有du这个方法，左边的Animals中也没有du这个方法，所以继承了Uncle类中的du方法
```
*`输出`*
```ruby
wangzy 吃的派生类的
wangzy Animals类中喝
wangzy 自己的类中汪
wangzy Uncle家中赌
```

- 继承顺序案例详解： 

图

```ruby
class A:
    def f1(self):
        print("A")

class B(A):
    def f(self):
        print("B")

class C(A):
    def f1(self):
        print("C")

class D(B,C):
    def f(self):
        print("D")

name = D()
name.f1()
```
```ruby
class A:
    def f1(self):
        print("A")

class B(A):
    def f1(self):
        print("B")

class C(A):
    def f1(self):
        print("C")

class D(B):
    def f1(self):
        print("D")

class E(C):    
    def f1(self):  # 可以将f1改为f，表示E中没有这个方法
        print("E")

class F(D,E):
    def f1(self):
        print("F")

name = F()
name.f1()
```

- ##### 多态：
多种形态，python本身支持多态
```ruby
class Foo:
    def f1(self):
        print("Foo")

class Bar:
    def f1(self):
        print("bar")

def func(arg):
    arg.f1()

func(Foo())
func(Bar())

```
*`输出`*
```ruby
Foo
bar
```
下面是其他语言需要指定的，而python不需要，下面这种指定方式就不是多态了：
```ruby
# Foo arg: arg必须是Foo类创建的对象
def func(Foo arg):
     arg.f1()
     
下面这是其他语言的多态展现：
class Father:
    pass

class Foo(Father):
    def f1(self):
        print("Foo")

class Bar(Father):
    def f1(self):
        print("Bar")

# Father arg：arg必须是Father类创建的对象或者是Father类的派生类创建的对象
def func(Father arg):
    arg.f1()
```

- ##### 重载：
函数名相同，参数个数不同（python不支持）

- ##### 重写：
派生类中重新实现基类中的方法 
```ruby
class People:
    def sleep(self):
        print("this is People Class")

class Man(People):
    def sleep(self):
        People.sleep(self)
        print("this is Man class")

user1 = Man()
user1.sleep()
```