
### Paramiko模块安装和使用

常见的解决方法都会需要对远程服务器必要的配置，如果远程服务器只有一两台还好说，如果有N台，还需要逐台进行配置，或者需要使用代码进行以上操作时，上面的办法就不太方便了。

使用paramiko可以很好的解决以上问题，比起前面的方法，它仅需要在本地上安装相应的软件（python以及PyCrypto），对远程服务器没有配置要求，对于连接多台服务器，进行复杂的连接操作特别有帮助。


pip下载：
https://pypi.python.org/pypi/pip#downloads
```ruby
C:\Users\Administrator>d:
D:\>cd python34\pip-9.0.1
D:\python34\pip-9.0.1>python setup.py install
......

Installing pip.exe.manifest script to D:\python34\Scripts

Installed d:\python34\lib\site-packages\pip-9.0.1-py3.4.egg
Processing dependencies for pip==9.0.1
Finished processing dependencies for pip==9.0.1

# 设置环境变量：
;D:\python34\Scripts;
C:\Users\Administrator>pip list
```

```ruby
D:\python34\paramiko-2.4.0>pip install --upgrade setuptools
参考链接：https://wiki.python.org/moin/WindowsCompilers
```

安装paramiko：
```ruby
C:\Users\Administrator>d:
D:\>cd python34\paramiko-2.4.0
D:\python34\paramiko-2.4.0>python setup.py install
running install
......
Installed d:\python34\lib\site-packages\pycparser-2.18-py3.4.egg
Searching for pyasn1==0.4.2
Best match: pyasn1 0.4.2
Processing pyasn1-0.4.2-py3.4.egg
pyasn1 0.4.2 is already the active version in easy-install.pth

Using d:\python34\lib\site-packages\pyasn1-0.4.2-py3.4.egg
Finished processing dependencies for paramiko==2.4.0

```
在pycharm中测试是否安装成功：
```ruby
import paramiko

# 运行
```

### SSHClient:

- 基于用户名密码连接：
```ruby
import paramiko

# 创建SSH对象
ssh = paramiko.SSHClient()
# 允许连接不在know_hosts文件中的主机
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
# 连接服务器
ssh.connect(hostname='172.30.105.115', port=22, username='root', password='wangzongyu')

# 执行命令
stdin, stdout, stderr = ssh.exec_command('df')
# 获取命令结果
result = stdout.read()
print(result.decode())

# 关闭连接
ssh.close()
```


- 基于公钥密钥连接：

`SSH秘钥认证：`
```ruby
# 将本机(172.30.105.115)的公钥(私钥不能传给别人)发给需要连接的主机(172.30.105.112)：

[root@localhost ~]# ssh-copy-id "-p2222 baby@172.30.105.112"
The authenticity of host '[172.30.105.112]:2222 ([172.30.105.112]:2222)' can't be established.
RSA key fingerprint is 79:48:d2:8c:ff:19:f9:e5:a2:f5:d6:84:07:17:4c:bd.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '[172.30.105.112]:2222' (RSA) to the list of known hosts.
baby@172.30.105.112's password: 
Now try logging into the machine, with "ssh '-p2222 baby@172.30.105.112'", and check in:

  .ssh/authorized_keys

to make sure we haven't added extra keys that you weren't expecting.

# 使用ssh-copy-id这个命令是为了手动拷贝不能保证一行，这样拷贝能保证公钥在远程主机的这个文件中.ssh/authorized_keys保证是一行

[root@localhost ~]# ssh -p2222 baby@172.30.105.112

```

```ruby
import paramiko

private_key = paramiko.RSAKey.from_private_key_file('id_rsa_105-115')

# 创建SSH对象
ssh = paramiko.SSHClient()
# 允许连接不在know_hosts文件中的主机
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
# 连接服务器
ssh.connect(hostname='172.30.105.112', port=2222, username='baby', pkey=private_key)

# 执行命令
stdin, stdout, stderr = ssh.exec_command('df')
# 获取命令结果
result = stdout.read()
print(result.decode())

# 关闭连接
ssh.close()
```

### SFTPClient:

- 基于用户名密码上传下载:

```ruby
import paramiko

transport = paramiko.Transport(('172.30.105.112',2222))
transport.connect(username='baby',password='wangzongyu')

sftp = paramiko.SFTPClient.from_transport(transport)
# 将location.py 上传至服务器 /tmp/test.py
sftp.put('D:\Python27\LICENSE.txt', '/tmp/license_test.py')

#将remove_path 下载到本地 local_path
sftp.get('/tmp/snmpd.conf.bak', 'E:\result')

transport.close()
```


- 基于公钥密钥上传下载:
```ruby
import paramiko
 
private_key = paramiko.RSAKey.from_private_key_file('id_rsa_105-115')
 
transport = paramiko.Transport(('172.30.105.112', 2222))
transport.connect(username='baby', pkey=private_key )
 
sftp = paramiko.SFTPClient.from_transport(transport)
# 将location.py 上传至服务器 /tmp/test.py
sftp.put('/tmp/location.py', '/tmp/test.py')
# 将remove_path 下载到本地 local_path
sftp.get('remove_path', 'local_path')
 
transport.close()
```

#### 多线程实现
```ruby

# 方式一(类方式实现)：
import threading
import time

class MyThread(threading.Thread):
    def __init__(self,n):
        super(MyThread,self).__init__() # 因为重构了父类的方法，所以要继承
        self.n = n

    def run(self):  # 这必须是run方法
        print("runnint task",self.n)

t1 = MyThread("t1")
t2 = MyThread("t2")

t1.start()
t2.start()


#方式二：
import threading
import time

def run(n):
    print("task",n)
    time.sleep(2) # 如果不加上sleep，就不能演示出多线程和下面直接写run("t1")的区别

t1 = threading.Thread(target=run,args=('t1',))  #run后面没有括号，元组形式，所以最后也要加一个逗号
t2 = threading.Thread(target=run,args=('t2',))

t1.start()
t2.start()  # t1和t2是同时进行的

#run("t1")  # 通过上面的sleep就能发现这种方式与多线程执行的区别
#run("t2")

```
`主线程不会等待所有的子线程执行完成，各自执行`
```ruby
import threading
import time

class MyThread(threading.Thread):
    def __init__(self,n,sleep_time):
        super(MyThread,self).__init__()
        self.n = n
        self.sleep_time = sleep_time

    def run(self):
        print("runnint task",self.n)
        time.sleep(self.sleep_time)
        print("task done",self.n)

t1 = MyThread("t1",2)
t2 = MyThread("t2",4)

'''
t1.start()
t1.join()  # 等待t1线程执行完成，在其他语言中是t1.wait()
# 加了join的作用是等待第一个线程执行完毕，才会去执行第二个线程，这样多线程之间就变成了串行执行
t2.start()
# 在整个程序的执行最后，其实默认还有一个t2.join，因为只有所有的"并发"线程都执行完成，程序最后才打印"Process finished with exit code 0"
'''

# 为了还是使多线程执行，还要计算执行时间，可以按照下面的方式
t1.start()
t2.start()

t1.join()

print("main thread!")  # 本身这个程序就启动了一个进程就是主线程，t1和t2分别是两个子线程；
# 主线程不会等待所有的子线程执行完成，各自执行
```
`运行结果`
```ruby
runnint task t1
runnint task t2
task done t1
main thread!
task done t2

Process finished with exit code 0
```
`如果想执行50个进程，并且查看总的执行时间呢？`
```ruby
import threading
import time

def run(n):
    print("running task",n)
    time.sleep(2)

start_time = time.time()
t_objs = []
for i in range(50):
    t = threading.Thread(target=run,args=('t%s' %i,))
    t.start()
    # t.join() # 不能写在这，这样写就变成串行执行了，需要使用空列表实现
    t_objs.append(t)

for t in t_objs:
    t.join()

print("-------------- all threads has finished!")
print("total run time",time.time() - start_time)

# # t1.start()
# # t2.start()  # t1和t2是同时进行的
#
# run("t1")
# run("t2")

```
`运行结果`
```ruby
running task t0
running task t1
running task t2
running task t3
running task t4
running task t5
......
running task t44
running task t45
running task t46
running task t47
running task t48
running task t49
-------------- all threads has finished!
total run time 2.0111148357391357

```