## 装饰器 ##
**定义：** 
- ###### 本质是函数，（装饰其他函数） 就是为其他函数添加附加功能
**原则：** 
- ###### 不能修改被装饰的函数的源代码
- ###### 不能修改被装饰的函数的调用方式

**实现装饰器知识储备：** 
- ###### 函数即变量
- ###### 高阶函数
- ###### 嵌套函数

**高阶函数 + 嵌套函数 => 装饰器** 

- 函数即变量  

![](https://github.com/ZongYuWang/Operation/blob/master/image/decorator1.png)
###### 【说明】可以将整个内存空间比喻成一个大房子，然后将1或者是定义的函数体放到任何一个屋子里，而门牌号就相当于是x或定义的函数名(test)

##### 扩展说明：内存回收机制
![](https://github.com/ZongYuWang/Operation/blob/master/image/decorator2.png)  

###### 【说明】1分别被x和y引用了2次，当x这个"门牌号"和y这个"门牌号"都不存在的时候，1就被python解释器释放了
###### 【注意】当使用del或者程序结束的时候，x的引用才被删除，但是1这个值不会被删除，只有下次在刷新的时候，发现1没有被引用的时候，才会删除，del命令和程序结束只能"摘掉"的"门牌号"

**匿名函数**
```py
lambda x:x*3
【说明】匿名函数没有名字，所以python立刻会被回收

cale = lambda x:x*3
【说明】如果将匿名函数赋值给一个变量，那么这个匿名函数就有了"门牌号"=calc
```
##### 通过上面的“函数即变量”内容再来看函数调用的案例：
```py
调用方式1：可以正常执行
def bar():
    print("in the bar")
def foo():
    print("in the foo")
    bar()
foo()


调用方式2：
def bar():
    print("in the bar")
    foo()
def foo():
    print("in the foo")
bar()

【说明】两个函数调用类似：x=1，y=2 print(x,y)
	                y=2, x=1 print(x,y)
	          
``` 
*打印输出*
```py
in the bar
in the foo
```

**高阶函数**
- ###### 把一个函数名当做实参传给另外一个函数（在不修改被装饰函数源代码的情况下为其添加功能）
- ###### 返回值中包含函数名（不修改函数的调用方式）

```py
>>> def bar():
...     pass

... bar
<function bar at 0x02986ED0>
【说明】单独输入bar输出的一串其实就是门牌号，bar(）就是基于这个地址在做调用

def bar():
    print('in the bar')

def test1(func):
    print(func)

test1(bar)
```
*打印输出*
```py
<function bar at 0x006E3270>

【说明】根据上面的说明，直接调用函数名，其实就是输出一串函数的“内存地址”，此例中将bar传给了func（func=bar），print(bar)就是输出bar的一串内存地址

```

###### 扩展上面的例子
```py
def bar():
    print('in the bar')

def test1(func):
    print(func)
    func()

test1(bar)

```
*打印输出*
```py
<function bar at 0x00633270>
in the bar
```
##### 高阶函数使用——打印函数的运行时间
```py
import time
def bar():
    time.sleep(2)   # 休眠2秒
    print('in the bar')

bar() #函数名加括号的方式是直接调用函数的方式，会执行函数体，如果不加括号，因为函数即变量，会输出函数的内存地址

def test1(func):
    start_time = time.time()
    func()
    stop_time = time.time()
    print('the func run time is %s' %(stop_time-start_time))

test1(bar)

【说明】高阶函数调用的时候不要加()，加上()是吧bar的返回结果传给了test1

```
*打印输出*
```py

in the bar
in the bar
the func run time is 2.0001139640808105

```

**嵌套函数**
```py
def foo():
    print('in the foo')
    def bar():
        print('in the bar')
    bar()
foo()
【说明】嵌套函数也必须在函数体内使用def定义

下面的方式不是嵌套函数：
def bar():
        print('in the bar')
        
def foo():
    print('in the foo')  
    bar()  # 这样不叫嵌套函数，这是函数调用
foo()

```
##### 局部作用域和全局作用域的访问顺序
```py
x = 0
def grandpa():   # x=0
    #x = 1
    def dad():
        x = 2
        def son():
            x = 3
            print("inside son",x)
        son()
        print("inside dad",x)
    dad()
    print("inside grandpa",x)
grandpa()
print("------>",x)

【说明】建议使用断点查看程序执行顺序：先执行def，然后到最后看看是否有调用，如果有调用，再回到def定义的，再向下执行，如果再有def，那么再去看是否有调用，最后输出会先输出最里面的

```
*打印输出*
```py
inside son 3
inside dad 2
inside grandpa 0
------> 0

```
