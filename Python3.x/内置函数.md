- all（全真时才为真）
```py
print( all([0,-5,3]) )
输出：
False
```

- any（有一为真就是真）
```py
print( any([1,-5,3]) )
输出：
True

print( any([ ]) )
输出：
False
```
- bin(把数字十进制转换为二进制)
```py
>>> bin(1)
'0b1'
>>> bin(2)
'0b10'
>>> bin(4)
'0b100'
>>> bin(8)
'0b1000'
>>> bin(255)
'0b11111111'

```

- bytearray(打印字符的ASCII码)
```py
a = bytes('abcd',encoding='utf-8')
print(a)
print(a.capitalize(),a)
输出：
b'abcd'
b'Abcd' b'abcd'

b = bytearray('abcd',encoding='utf-8')
print(b[0])
print(b[2])
输出：
97
99

b = bytearray('abcd',encoding='utf-8')
print(b)
b[1] = 100
print(b)
输出：
bytearray(b'abcd')
bytearray(b'adcd')

```
- callale（是否可以调用，也就是是否可以加括号）
```py
print( callable([1,2,3]) )
输出：
False

def test():
    pass
print( callable(test) )
输出：
True

```
- chr
```py
>>> chr(87)
'W'
>>> chr(97)
'a'
```
- ord
```py
>>> ord('d')
100
>>> ord('b')
98

```
- exec
```py

code = '''
def test():
    print('this is a exec test fun')
test()
'''

py_obj = compile(code,"error.log","exec")
exec(py_obj)

```
- dir
```py
>>> a = {}
>>> dir(a)
['__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']

```
- divmod
```py
>>> divmod(5,2)
(2, 1)            #2是商，1是余数
>>> divmod(5,1)
(5, 0)
>>> divmod(5,3)
(1, 2)
```
- enumerate
```py

前面介绍过
```
- eval
```py
字符串转换成列表：
>>>a = "[[1,2], [3,4], [5,6], [7,8], [9,0]]"
>>>type(a)
<type 'str'>
>>> b = eval(a)
>>> print b
[[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]]

字符串转换成字典：
>>> a = "{1: 'a', 2: 'b'}"
>>> type(a)
<type 'str'>
>>> b = eval(a)
>>> print b
{1: 'a', 2: 'b'}
>>> type(b)
<type 'dict'>

字符串转换成元组：
>>> a = "([1,2], [3,4], [5,6], [7,8], (9,0))"
>>> type(a)
<type 'str'>
>>> b = eval(a)
>>> print b
([1, 2], [3, 4], [5, 6], [7, 8], (9, 0))
>>> type(b)
<type 'tuple'>

```
- filter
```py

#普通函数：
def test1(n):
    print(n)
test1(2)

#匿名函数：
calc = lambda n:print(n)
calc(5)
也可以写成下面的形式：
(lambda n:print(n))(5)

【注意】匿名函数是不能处理复杂过程的，如：
calc = lambda n:for i in range(n):print(i)
calc(5)

res = filter(lambda n:n>5,range(10)) # 直接print(res)返回的是一个迭代器
for i in res:
    print(i)
```
- map
```py
res = map(lambda n:n*n,range(10)) #[ i*2 for i in range(10) ]
for i in res:
    print(i)
```
- reduce
```py
import functools
res = functools.reduce( lambda x,y:x+y,range(10))
print(res)
输出：
45
```
- frozenset(冻结，使其不可变)
```py
a = frozenset([1,2,3,4,5,67,8])
a.x
```

- hash
```py
>>> hash(1234)
1234
>>> hash('wangzy')
960264712
>>> hash('wangzy')
960264712
>>> hash('wang')
137298394
```

- hex(把数字转换成十六进制)
```py
>>> hex(10)
'0xa'
>>> hex(15)
'0xf'
>>> hex(255)
'0xff'
```
- oct(转换成八进制)
```py
>>> oct(1)
'0o1'
>>> oct(5)
'0o5'
>>> oct(8)
'0o10'
```
- locals打印局部变量：
```py

def test():
    local_var = 333
    print(locals())
test()
```

- pow(计算多少次方)：
```py
>>> pow(3,5)
243
>>> pow(3,3)
27
>>> pow(2,8)
256
```
- round(保留小数位数)
```py
>>> round(1.2889)
1
>>> round(1.2889,3)
1.289
>>> round(1.2889,2)
1.29
```
- sorted(字典排序)
```py
dir = {2:55,56:43,34:1,98:98,-1:40,66:-10}
print( sorted(dir.items()))
【说明】单独写sorted(dir)只输出key值的排序
输出：
[(-1, 40), (2, 55), (34, 1), (56, 43), (66, -10), (98, 98)]

对value值进行排序：
dir = {2:55,56:43,34:1,98:98,-1:40,66:-10}
print( sorted(dir.items(), key=lambda x:x[1]) )
输出：
[(66, -10), (34, 1), (-1, 40), (56, 43), (2, 55), (98, 98)]
【说明】第一个x表示每一个元素，也就是2:55这是一个元素，按照元素里面的[1]排序
```
- zip(拉链匹配)：
```py
a = [1,2,3,4]
b = ['a','b','c','d','e']

print( zip(a,b) ) #在python2中这样可以直接打印，python3中需要使用下面的方式，python3中zip被定义成了迭代器

for i in zip(a,b):
    print(i)

输出：
<zip object at 0x021467D8>
(1, 'a')
(2, 'b')
(3, 'c')
(4, 'd')
【说明】如果数量不匹配，按照少数的匹配原则
```
- \__import__(左右都是两个小的下划线)
```py
import decorator
等价于：
__import__('decorator')
```