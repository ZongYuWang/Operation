## 生成器 ##

- 生成器的执行流程：

```py
def zrange(n):
    print("beginning of zrange")
    i = 0
    while i < n :
        print("before yield",i)
        yield i
        i += 1
        print("after yield",i)
    print("endding of zrange" )

Zrange = zrange(3)
print(Zrange)
print("****************")

Zrange.__next__()
print("----------------")

Zrange.__next__()
print("++++++++++++++++")

Zrange.__next__()
print("================")

Zrange.__next__()
print("################")

```
*打印输出*
```py
<generator object zrange at 0x004B78C8>
****************
beginning of zrange
before yield 0
----------------
after yield 1
before yield 1
++++++++++++++++
after yield 2
before yield 2
================
after yield 3
endding of zrange
Traceback (most recent call last):
  File "E:/PycharmProjects/untitled/study/day4/122.py", line 27, in <module>
    Zrange.__next__()
StopIteration

```
###### 通过运行结果可以看出：
- 当调用生成器函数的时候，函数只是返回了一个生成器对象，并没有执行；
- 当__next__()方法第一次被调用的时候，生成器函数才开始执行，执行到yield语句处停止， yield语句处的参数(yield value)就是__next__()方法的返回值
- 当继续调用__next__()方法的时候，函数将接着上一次停止的yield语句处继续执行，并到下一个yield处停止，如果后面没有yield就抛出Stoplteration异常

**生成器表达式：**
当序列过长，而每次只需要获取一个元素时，应当考虑使用生成器表达式而不是列表解析，生成器表达式的语法和列表解析一样，只不过生成器表达式是被()括起来的，而不是[]，如下：



这地是代码



生成器表达式并不是创建一个列表，而是返回一个生成器，这个生成器在每次计算出一个条目后，把这个条目“产生”(yield)出来，生成器表达式使用了“惰性计算”，只有在检索时才被赋值，所以在列表比较长的情况下使用内存上更有效
```py
test = ( i for i in range(10) if i%2 )

print("__iter__" in dir(test))
print("__next__" in dir(test))
print(sum(test))

【说明】生成器表达式产生的生成器，它自身是一个可迭代对象，同时也是迭代器本身

```

**递归生成器：**




**生成器的send()和close()方法**

- send(value):  

从前面了解到，__next__方法可以恢复生成器状态并继续执行，其实send()是除__next__外另一个恢复生成器的方法。

yield语句也可以是yield表达式，也就是说yield可以有一个值，而这个值就是send()方法的参数，所以send(None)和next()是等效的。同样，next()和send()的返回值都是yield语句处的参数（yielded value）

关于send()方法需要注意的是：调用send传入非None值前，生成器必须处于挂起状态，否则将抛出异常。也就是说，第一次调用时，要使用next()语句或send(None)，因为没有yield语句来接收这个值。

close():
这个方法用于关闭生成器，对关闭的生成器后再次调用next或send将抛出StopIteration异常。


#### 总结

- 通过实现迭代器协议对应的__iter__()和next()方法，可以自定义迭代器类型。对于可迭代对象，for语句可以通过iter()方法获取迭代器，并且通过next()方法获得容器的下一个元素。
- 像列表这种序列类型的对象，可迭代对象和迭代器对象是相互独立存在的，在迭代的过程中各个迭代器相互独立；但是，有的可迭代对象本身又是迭代器对象，那么迭代器就没法独立使用。
- itertools模块提供了一系列迭代器，能够帮助用户轻松地使用排列、组合、笛卡尔积或其他组合结构。
- 生成器是一种特殊的迭代器，内部支持了生成器协议，不需要明确定义__iter__()和next()方法。
- 生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用return返回，而是用yield一次返回一个结果。

## 迭代器 ##
- 迭代器是一个带状态的对象，他能在你调用next()方法的时候返回容器中的下一个值，任何实现了__iter__和__next__()（python2中实现next()）方法的对象都是迭代器，__iter__返回迭代器自身，__next__返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration异常，至于它们到底是如何实现的这并不重要。所以，迭代器就是实现了工厂模式的对象，它在你每次你询问要下一个值的时候给你返回

#### 总结

- 容器是一系列元素的集合，str、list、set、dict、file、sockets对象都可以看作是容器，容器都可以被迭代（用在for，while等语句中），因此他们被称为可迭代对象。
- 可迭代对象实现了__iter__方法，该方法返回一个迭代器对象。
- 迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了__next__和__iter__方法，迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果。
- 生成器是一种特殊的迭代器，它的返回值不是通过return而是用yield。