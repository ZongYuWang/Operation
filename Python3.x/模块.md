
#### 引用自定义模块的路径问题：
![](https://github.com/ZongYuWang/image/blob/master/python-module1.png)  
- 打印相对路径：
```ruby
print(__file__) #这个其实是打印的文件的相对路径，但是在paycharm中由于软件问题打印的是绝对路径
```
*`输出`*
```ruby
E:\PycharmProjects\untitled\study>python ATM\test\Module_Path.py
ATM\test\Module_Path.py   # 打印的相对路径

```
- 打印绝对路径：
```ruby
import os
print(os.path.abspath(__file__))
```
*`输出`*
```ruby
E:\PycharmProjects\untitled\study>python ATM\test\Module_Path.py
E:\PycharmProjects\untitled\study\ATM\test\Module_Path.py

```
返回目录名，不要文件名：
```ruby
import os
print(os.path.dirname(  os.path.abspath(__file__)  ))
```
*`输出`*
```ruby
E:\PycharmProjects\untitled\study>python ATM\test\Module_Path.py
E:\PycharmProjects\untitled\study\ATM\test

```
可以再返回一级：
```ruby
import os
# print(os.path.dirname(  os.path.abspath(__file__)  ))
print(os.path.dirname(  os.path.dirname (os.path.abspath(__file__)  ) ))
```
*`输出`*
```ruby
E:\PycharmProjects\untitled\study>python ATM\test\Module_Path.py
E:\PycharmProjects\untitled\study\ATM

```
添加环境变量，并调用其他目录下的文件：
*`main.py 的文件内容：`*
```ruby

print("in the core-main")

def login():
    print("in the core-main-login")
```
*`settings.py 的文件内容：`*
```ruby
print("in the conf-settings")
```

```ruby
BASE_DIR = os.path.dirname(  os.path.dirname (os.path.abspath(__file__)  ))
sys.path.append(BASE_DIR)

# import conf,core
from conf import settings
from core import main

main.login()
```
*`输出`*
```ruby
in the conf-settings
in the core-main
in the core-main-login
```

###### 模块的定义：
模块用来从逻辑上组织python代码(变量、函数、类、逻辑：实现一个功能)，本质就是.py结尾的python文件（文件名：test.py，对应的模块名：test）

###### 模块导入方法：
- import module_name
- import module_name1,module_name2
- from module_path import *  (这种方式不推荐使用)
- from module_path import module_name1,module_name2
- from module_path import say_hello as hello

*`module_path.py 的文件内容：`*
```ruby
name = 'wangzy'

def say_hello():
    print('hello wangzy')
    
def logger():
    pass

def module2():
    pass
```
*`main.py 的文件内容：`*
```ruby
import module_path
# from module_path import * #比如module_path下有很多方法，想全部导入的话使用这种方式，但是不建议使用(原因见下方解释)

print(module_path.name)
print(module_path.say_hello())
```
*`执行main输出结果：`*
```ruby
wangzy
hello wangzy
None   # 调用方法：返回一个none，是因为这个函数没有返回值

```

module_path里面有一个logger方法，main里面也有一个logger方法，这样就不知道以哪个为准，所以import * 不推荐使用
*`module_path.py 的文件内容：`*
```ruby
def say_hello():
    print('hello wangzy')


def logger():
    print('in the module_path-logger')

def module2():
    pass
```

*`main.py 的文件内容：`*
```ruby
from module_path import *  #实际上是把module_path下面的代码都复制进来

def logger():
    print('in the main-logger')  
#所以是这个生效，因为两个logger方法，前面隐性的导入一个，函数即变量，两个相同的变量名，后者定义的生效

logger()
```
*`输出`*
```ruby
in the main-logger  # 可以看出执行的main的logger方法，import导入的(其中包含logger方法)没有被执行
```

- import和from import的区别：
```ruby
import module_path
from module_path import *
【说明】from...import ...是相当于把module里面的代码全都复制进来
所以如果想调用logger方法，直接写logger()就行了，不能再使用module_path.logger()
```

- from...import...as方式：

*`main.py 的文件内容：`*
```ruby
from module_path import logger as logger_wangzy

def logger():
    print('in the main-logger')

logger()
logger_wangzy()
```
*`输出`*
```ruby
in the main-logger
in the module_path-logger
```
###### import本质(路径搜索和搜索路径)：
import module_path就相当于把 module_path整个“解释”了一遍，将结果赋值给了module_path
```ruby
import module_path
# module_path=all_code
```

###### 导入优化：


###### 模块的分类：
