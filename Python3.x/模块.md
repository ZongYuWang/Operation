
#### 引用自定义模块的路径问题：
![](https://github.com/ZongYuWang/image/blob/master/python-module1.png)  
- 打印相对路径：
```ruby
print(__file__) #这个其实是打印的文件的相对路径，但是在paycharm中由于软件问题打印的是绝对路径
```
*`输出`*
```ruby
E:\PycharmProjects\untitled\study>python ATM\test\Module_Path.py
ATM\test\Module_Path.py   # 打印的相对路径

```
- 打印绝对路径：
```ruby
import os
print(os.path.abspath(__file__))
```
*`输出`*
```ruby
E:\PycharmProjects\untitled\study>python ATM\test\Module_Path.py
E:\PycharmProjects\untitled\study\ATM\test\Module_Path.py

```
返回目录名，不要文件名：
```ruby
import os
print(os.path.dirname(  os.path.abspath(__file__)  ))
```
*`输出`*
```ruby
E:\PycharmProjects\untitled\study>python ATM\test\Module_Path.py
E:\PycharmProjects\untitled\study\ATM\test

```
可以再返回一级：
```ruby
import os
# print(os.path.dirname(  os.path.abspath(__file__)  ))
print(os.path.dirname(  os.path.dirname (os.path.abspath(__file__)  ) ))
```
*`输出`*
```ruby
E:\PycharmProjects\untitled\study>python ATM\test\Module_Path.py
E:\PycharmProjects\untitled\study\ATM

```
添加环境变量，并调用其他目录下的文件：
*`main.py 的文件内容：`*
```ruby

print("in the core-main")

def login():
    print("in the core-main-login")
```
*`settings.py 的文件内容：`*
```ruby
print("in the conf-settings")
```

```ruby
import sys
print(sys.path)  # 打印出当前的路径

BASE_DIR = os.path.dirname(  os.path.dirname (os.path.abspath(__file__)  ))
sys.path.append(BASE_DIR)

# import conf,core
from conf import settings
from core import main

main.login()
```
*`输出`*
```ruby
in the conf-settings
in the core-main
in the core-main-login
```

#### 模块的定义：
模块用来从逻辑上组织python代码(变量、函数、类、逻辑：实现一个功能)，本质就是.py结尾的python文件（文件名：test.py，对应的模块名：test）
包：用来从逻辑上组织模块的，本质就是一个目录(必须带有一个__init__.py文件)

#### 模块导入方法：
- import module_name
- import module_name1,module_name2
- from module_path import *  (这种方式不推荐使用)
- from module_path import module_name1,module_name2
- from module_path import say_hello as hello

*`module_path.py 的文件内容：`*
```ruby
name = 'wangzy'

def say_hello():
    print('hello wangzy')
    
def logger():
    pass

def module2():
    pass
```
*`main.py 的文件内容：`*
```ruby
import module_path
# from module_path import * #比如module_path下有很多方法，想全部导入的话使用这种方式，但是不建议使用(原因见下方解释)

print(module_path.name)
print(module_path.say_hello())
```
*`执行main输出结果：`*
```ruby
wangzy
hello wangzy
None   # 调用方法：返回一个none，是因为这个函数没有返回值

```

module_path里面有一个logger方法，main里面也有一个logger方法，这样就不知道以哪个为准，所以import * 不推荐使用
*`module_path.py 的文件内容：`*
```ruby
def say_hello():
    print('hello wangzy')


def logger():
    print('in the module_path-logger')

def module2():
    pass
```

*`main.py 的文件内容：`*
```ruby
from module_path import *  #实际上是把module_path下面的代码都复制进来

def logger():
    print('in the main-logger')  
#所以是这个生效，因为两个logger方法，前面隐性的导入一个，函数即变量，两个相同的变量名，后者定义的生效

logger()
```
*`输出`*
```ruby
in the main-logger  # 可以看出执行的main的logger方法，import导入的(其中包含logger方法)没有被执行
```

- import和from import的区别：
```ruby
import module_path
from module_path import *
【说明】from...import ...是相当于把module里面的代码全都复制进来
所以如果想调用logger方法，直接写logger()就行了，不能再使用module_path.logger()
```

- from...import...as方式：

*`main.py 的文件内容：`*
```ruby
from module_path import logger as logger_wangzy

def logger():
    print('in the main-logger')

logger()
logger_wangzy()
```
*`输出`*
```ruby
in the main-logger
in the module_path-logger
```
#### import本质(路径搜索和搜索路径)：
import module_path就相当于把 module_path整个“解释”了一遍，将结果赋值给了module_path
导入模块的本质就是把python文件解释一遍
```ruby
import module_path
# module_path=all_code  #这种方式就相当于把所有的代码赋值给了一个变量

如果想调用变量：
module_path.name  #name是module_path中定义的变量

如果想调用方法：
module_path.logger  #logger是module_path中定义的方法
```
```ruby
from module_path import name
name = 'wangzy'
# 导入的是name变量，所以想使用这个变量，就可以直接使用了
```
导入包的本质就是执行该包下的__init__.py文件
```ruby
和test、logs同级别创建一个p_test.py文件，内容如下：
import test #导入包

test包下的__init__.py内容如下：
print('in the test-init')

执行p_test.py文件，运行结果如下：
in the test-init
```

- 跨越包(目录)调用里面的.py文件：

通过导入包的形式：
*` 通过上面的实验知道导入通过import 包名，其实执行的__init__.py文件 `*

*`p_test.py 的文件内容：`*
```ruby
import core  #import的是目录名

core.main.login()
#【说明】根据上面说明 import 后面的就是把core下的所有代码赋值给core，core就当一个变量名，调用core下面的方法时就用core.
因为这个import的是文件名(包)，包默认执行的是__init__.py下的文件内容，__init__.py和main.py在同级目录，所以可以直接import main
```
*`core下的__init__.py 的文件内容：`*
```ruby
from . import main  #这个.是相对路径，也就是相对于__init__.py的相对路径
```
*`core下的main.py 的文件内容：`*
```ruby
print("in the core-main")

def login():
    print("in the core-main-login")
```
*`输出`*
```ruby
in the core-main
in the core-main-login
```
#### 导入优化：
*`module_path.py 的文件内容：`*
```ruby
def test():
    print('in the module_path')
```
*`main.py 的文件内容：`*
```ruby
import module_path

def logger():
    module_path.test()  #重复的调用 module_path.test()方法，就需要每次都去查找module_path模块
    print('in the logger')

def search():
    module_path.test()  #重复的调用 module_path.test()方法
    print('in the search')
```
代码优化：
```ruby
from module_path import test  
#只导入一次，也就是把test方法的代码粘贴过来了，下面直接调用就行了，省去了每次查找的过程

def logger():
    test()
    print('in the logger')

def search():
    test()
    print('in the search')
```

#### 模块的分类：
