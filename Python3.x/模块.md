
#### 引用自定义模块的路径问题：
![](https://github.com/ZongYuWang/image/blob/master/python-module1.png )  
- 打印相对路径：
```ruby
print(__file__) #这个其实是打印的文件的相对路径，但是在paycharm中由于软件问题打印的是绝对路径
```
*`输出`*
```ruby
E:\PycharmProjects\untitled\study>python ATM\test\Module_Path.py
ATM\test\Module_Path.py   # 打印的相对路径

```
- 打印绝对路径：
```ruby
import os
print(os.path.abspath(__file__))
```
*`输出`*
```ruby
E:\PycharmProjects\untitled\study>python ATM\test\Module_Path.py
E:\PycharmProjects\untitled\study\ATM\test\Module_Path.py

```
返回目录名，不要文件名：
```ruby
import os
print(os.path.dirname(  os.path.abspath(__file__)  ))
```
*`输出`*
```ruby
E:\PycharmProjects\untitled\study>python ATM\test\Module_Path.py
E:\PycharmProjects\untitled\study\ATM\test

```
可以再返回一级：
```ruby
import os
# print(os.path.dirname(  os.path.abspath(__file__)  ))
print(os.path.dirname(  os.path.dirname (os.path.abspath(__file__)  ) ))
```
*`输出`*
```ruby
E:\PycharmProjects\untitled\study>python ATM\test\Module_Path.py
E:\PycharmProjects\untitled\study\ATM

```
添加环境变量，并调用其他目录下的文件：
*`main.py 的文件内容：`*
```ruby

print("in the core-main")

def login():
    print("in the core-main-login")
```
*`settings.py 的文件内容：`*
```ruby
print("in the conf-settings")
```

```ruby
import sys
print(sys.path)  # 打印出当前的路径

BASE_DIR = os.path.dirname(  os.path.dirname (os.path.abspath(__file__)  ))
sys.path.append(BASE_DIR)

# import conf,core
from conf import settings
from core import main

main.login()
```
*`输出`*
```ruby
in the conf-settings
in the core-main
in the core-main-login
```

#### 模块的定义：
模块用来从逻辑上组织python代码(变量、函数、类、逻辑：实现一个功能)，本质就是.py结尾的python文件（文件名：test.py，对应的模块名：test）
包：用来从逻辑上组织模块的，本质就是一个目录(必须带有一个__init__.py文件)

#### 模块导入方法：
- import module_name
- import module_name1,module_name2
- from module_path import *  (这种方式不推荐使用)
- from module_path import module_name1,module_name2
- from module_path import say_hello as hello

*`module_path.py 的文件内容：`*
```ruby
name = 'wangzy'

def say_hello():
    print('hello wangzy')
    
def logger():
    pass

def module2():
    pass
```
*`main.py 的文件内容：`*
```ruby
import module_path
# from module_path import * #比如module_path下有很多方法，想全部导入的话使用这种方式，但是不建议使用(原因见下方解释)

print(module_path.name)
print(module_path.say_hello())
```
*`执行main输出结果：`*
```ruby
wangzy
hello wangzy
None   # 调用方法：返回一个none，是因为这个函数没有返回值

```

module_path里面有一个logger方法，main里面也有一个logger方法，这样就不知道以哪个为准，所以import * 不推荐使用
*`module_path.py 的文件内容：`*
```ruby
def say_hello():
    print('hello wangzy')


def logger():
    print('in the module_path-logger')

def module2():
    pass
```

*`main.py 的文件内容：`*
```ruby
from module_path import *  #实际上是把module_path下面的代码都复制进来

def logger():
    print('in the main-logger')  
#所以是这个生效，因为两个logger方法，前面隐性的导入一个，函数即变量，两个相同的变量名，后者定义的生效

logger()
```
*`输出`*
```ruby
in the main-logger  # 可以看出执行的main的logger方法，import导入的(其中包含logger方法)没有被执行
```

- import和from import的区别：
```ruby
import module_path
from module_path import *
【说明】from...import ...是相当于把module里面的代码全都复制进来
所以如果想调用logger方法，直接写logger()就行了，不能再使用module_path.logger()
```

- from...import...as方式：

*`main.py 的文件内容：`*
```ruby
from module_path import logger as logger_wangzy

def logger():
    print('in the main-logger')

logger()
logger_wangzy()
```
*`输出`*
```ruby
in the main-logger
in the module_path-logger
```
#### import本质(路径搜索和搜索路径)：
import module_path就相当于把 module_path整个“解释”了一遍，将结果赋值给了module_path
导入模块的本质就是把python文件解释一遍
```ruby
import module_path
# module_path=all_code  #这种方式就相当于把所有的代码赋值给了一个变量

如果想调用变量：
module_path.name  #name是module_path中定义的变量

如果想调用方法：
module_path.logger  #logger是module_path中定义的方法
```
```ruby
from module_path import name
name = 'wangzy'
# 导入的是name变量，所以想使用这个变量，就可以直接使用了
```
导入包的本质就是执行该包下的__init__.py文件
```ruby
和test、logs同级别创建一个p_test.py文件，内容如下：
import test #导入包

test包下的__init__.py内容如下：
print('in the test-init')

执行p_test.py文件，运行结果如下：
in the test-init
```

- 跨越包(目录)调用里面的.py文件：

通过导入包的形式：
*` 通过上面的实验知道导入通过import 包名，其实执行的__init__.py文件 `*

*`p_test.py 的文件内容：`*
```ruby
import core  #import的是目录名

core.main.login()
#【说明】根据上面说明 import 后面的就是把core下的所有代码赋值给core，core就当一个变量名，调用core下面的方法时就用core.
因为这个import的是文件名(包)，包默认执行的是__init__.py下的文件内容，__init__.py和main.py在同级目录，所以可以直接import main
```
*`core下的__init__.py 的文件内容：`*
```ruby
from . import main  #这个.是相对路径，也就是相对于__init__.py的相对路径
```
*`core下的main.py 的文件内容：`*
```ruby
print("in the core-main")

def login():
    print("in the core-main-login")
```
*`输出`*
```ruby
in the core-main
in the core-main-login
```
#### 导入优化：
*`module_path.py 的文件内容：`*
```ruby
def test():
    print('in the module_path')
```
*`main.py 的文件内容：`*
```ruby
import module_path

def logger():
    module_path.test()  #重复的调用 module_path.test()方法，就需要每次都去查找module_path模块
    print('in the logger')

def search():
    module_path.test()  #重复的调用 module_path.test()方法
    print('in the search')
```
代码优化：
```ruby
from module_path import test  
#只导入一次，也就是把test方法的代码粘贴过来了，下面直接调用就行了，省去了每次查找的过程

def logger():
    test()
    print('in the logger')

def search():
    test()
    print('in the search')
```

#### 模块的分类：
- time模块
```ruby
#时间戳：>>> help(time)
>>> import time
>>> time.time()
1508894893.688606 #是从1970年开始计算到现在时间的总秒数

>>> x=time.time()
>>> x
1508894975.322275
>>> x/3600/24/365  #转换成从1970年到现在经过的年数
47.84674579281694

>>> time.localtime()  #输出中国时间UTC
time.struct_time(tm_year=2017, tm_mon=10, tm_mday=25, tm_hour=9, tm_min=31, tm_sec=25, tm_wday=2, tm_yday=298, tm_isdst=0)
>>> time.timezone
-28800
>>> 28800/3600
8.0   #中国在东八区UTC+8


gtime： #传递是标准时间：tm_hour=1，localtime输出的是中国时间
>>> time.gmtime()
time.struct_time(tm_year=2017, tm_mon=10, tm_mday=25, tm_hour=1, tm_min=36, tm_sec=34, tm_wday=2, tm_yday=298, tm_isdst=0)
>>> help(time.gmtime)


>>> x=time.localtime()
>>> print(x)
time.struct_time(tm_year=2017, tm_mon=10, tm_mday=25, tm_hour=9, tm_min=40, tm_sec=18, tm_wday=2, tm_yday=298, tm_isdst=0)
>>> print(x.tm_year)  #单独输出年份
2017


>>> x=time.localtime(123456789)  # localtime后面传递参数，也就是时间戳总秒数
>>> print(x)
time.struct_time(tm_year=1973, tm_mon=11, tm_mday=30, tm_hour=5, tm_min=33, tm_sec=9, tm_wday=4, tm_yday=334, tm_isdst=0)
>>> print(x.tm_year)
1973
>>> print('this is 1973 days:%d' %x.tm_yday)
this is 1973 days:334


>>> x
time.struct_time(tm_year=1973, tm_mon=11, tm_mday=30, tm_hour=5, tm_min=33, tm_sec=9, tm_wday=4, tm_yday=334, tm_isdst=0)
>>> time.mktime(x)
123456789.0

strftime("格式"，struct_time) ——> "格式化的字符串"
strptime("格式化的字符串"，"格式") ——> "struct_time"

>>> help(time.strftime)
>>>> time.strftime("%Y-%m-%d %H:%M:%S",x)  #上面定义的x的时间戳值是123456789
'1973-11-30 05:33:09'
>>> x=time.localtime()
>>> time.strftime("%Y-%m-%d %H:%M:%S",x)
'2017-10-25 09:53:16'


# 日期字符串 转成  时间戳
>>> time.strptime('2017-10-25 09:53:16',"%Y-%d-%S %m:%M:%H") #有匹配顺序
time.struct_time(tm_year=2017, tm_mon=9, tm_mday=10, tm_hour=16, tm_min=53, tm_sec=25, tm_wday=6, tm_yday=253, tm_isdst=-1)

x.time_year=2017
x.tm_mon=09
x.tm_day=10
x.tm_hour=16
x.tm_min=53
x.tm_sec=25

>>> time.asctime()
'Wed Oct 25 10:11:01 2017'

>>> time.ctime()
'Wed Oct 25 10:11:42 2017'

#参数说明：
    %a  Locale's abbreviated weekday name.
    %A  Locale's full weekday name.
    %b  Locale's abbreviated month name.
    %B  Locale's full month name.
    %c  Locale's appropriate date and time representation.
    %d  Day of the month as a decimal number [01,31].
    %H  Hour (24-hour clock) as a decimal number [00,23].
    %I  Hour (12-hour clock) as a decimal number [01,12].
    %j    一年中的第几天（001 - 366）  
    %m  Month as a decimal number [01,12].
    %M  Minute as a decimal number [00,59].
    %p  Locale's equivalent of either AM or PM.
    %S  Second as a decimal number [00,61].
    %U  一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周
    %w  一个星期中的第几天（0 - 6，0是星期天）  
    %W  和%U基本相同，不同的是%W以星期一为一个星期的开始
    %x  本地相应日期    
    %X  本地相应时间    
    %y  去掉世纪的年份（00 - 99）
    %Y  Year with century as a decimal number.  
    %z  Time zone offset from UTC.
 
```
![](https://github.com/ZongYuWang/image/blob/master/python-module2.png) 

- datetime
```ruby
>>> import datetime

>>> datetime.datetime.now()
datetime.datetime(2017, 10, 25, 10, 13, 10, 880876)

>>> print(datetime.datetime.now())
2017-10-25 10:13:53.179296

>>> print(datetime.datetime.now())
2017-10-25 10:27:14.240114
>>> print(datetime.date.fromtimestamp(time.time()) )
2017-10-25
>>> print(datetime.datetime.now() )
2017-10-25 10:27:45.572906
>>> print(datetime.datetime.now() + datetime.timedelta(5)) #当前时间+5天
2017-10-30 10:27:59.171684
>>> print(datetime.datetime.now() + datetime.timedelta(-5)) #当前时间-5天
2017-10-20 10:28:11.420384
>>> print(datetime.datetime.now() + datetime.timedelta(hours=3))
2017-10-25 13:28:25.396183
>>> print(datetime.datetime.now() + datetime.timedelta(minutes=30))
2017-10-25 10:58:37.703887
```